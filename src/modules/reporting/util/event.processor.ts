/**
 * Defines an event that can be processed by the generic reporting framework.
 */
export interface ReportableEvent {
  getName(): string;
}

/**
 * Defines an event operator - a function that performs processing operations with the supplied event data
 * on the supplied target output object
 */
export type EventOperator<T, S> = (target: T, event: S) => Promise<T> | T;

/**
 * Defines a set of event operators, where the key maps to a given event name, and the value maps to an operator.
 */
export interface EventOperators<T, S> {
  [key: string]: EventOperator<T, S>;
}

/**
 * Defines event errors that were generated during the processing of a given event / set of events.
 */
export interface EventProcessingError<S> {
  event: S;
  error: any;
}

/**
 * Defines the shape of the result produced an event processors' complete event set processor (i.e. the processAll method).
 */
export interface EventProcessingResult<T, S> {
  target: T;
  errors: EventProcessingError<S>[];
}

/**
 * Defines a base event processor that is used to process events against a given target for the purposes of generating reporting
 * output.
 */
export abstract class AbstractEventProcessor<T, S extends ReportableEvent> {
  protected constructor(
    protected readonly events: EventOperators<T, S>,
    protected options: {
      noOpUndefined?: boolean;
    } = {},
  ) {}

  /**
   * Processes a single event against the supplied target.
   */
  public process(target: T, event: S): Promise<T> | T {
    /* Search for the supplied event and execute it if retrieved. */
    const operator = this.events[event.getName()];

    if (operator) {
      /* Execute the operator and return the result */
      return operator(target, event);
    }

    /* If the operator doesn't exist, check the no-op setting.  If it's not set to a truthy value, throw an exception. */
    if (!this.options.noOpUndefined) {
      throw new Error(
        `Cannot process event! no event operator exists for ${event.getName()}!  Available events: ` + `${Object.keys(this.events)}`,
      );
    }

    /* If we get here, simply return the inbound target. */
    return target;
  }

  /**
   * Processes a set of events against the supplied target
   */
  public processAll(target: T, events: S[]): Promise<EventProcessingResult<T, S>> {
    return this._processAll(
      target,
      () => events,
      evt => this.process(target, evt),
    );
  }

  /**
   * Internal method that processes a set of entity events (retrieved by the supplied getEntityEvents cb; processed via the supplied
   * processOne cb) against the supplied target.
   */
  protected _processAll<U = S>(
    target: T,
    getEntityEvents: () => U[],
    processOne: (eventData: U) => Promise<T> | T,
  ): Promise<EventProcessingResult<T, S>> {
    /* Will be using this collection to keep track of promises generated by handlers... */
    const promises: Promise<any>[] = [];
    const errors = [];

    /* Retrieve the set by invoking the supplied callback via the supplied handler */
    getEntityEvents().forEach(entityEvent => {
      /* Assuming that objects will be modified in-place */
      try {
        const v = processOne(entityEvent);

        /* If the returned value is a promise, we will need to track it. */
        if (v instanceof Promise) {
          promises.push(v.catch(err => errors.push({ event: entityEvent, error: err })));
        }
      } catch (error) {
        /* If the processor generates an exception, we will continue processing of the records, but we need to track errors... */
        errors.push({ event: entityEvent, error });
      }
    });

    /* Return coordinating promise - resolve with the modified-in-place target, and the error set. */
    return Promise.all(promises).then(() => {
      return { target, errors };
    });
  }
}
